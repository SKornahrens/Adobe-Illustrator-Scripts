/*   ** ======================================   **     ** FATALITY v3 (v1 and v2 have less functionality, considered obsolete)   **    ** This script preforms the following actions in this order in Illustrator CC 2017 for StickerGiant Art Team.   **   ** 1. Finds and selects all magenta Die Lines found in current document   ** 2. Creates artboards for every selected Die Line at their geometric bound in order of Die Line placement    ** 3. Measures the die line height and width, applies labels for height and width to the hundredth decimal place value   ** 4. Prompts the user for Folder/File name     ** 5. Searches the StickerGiant server (/Volumes/ShrData/server_docs/custom_stickers/Art For Robb) for a folder matching step4 user input   ** 6a. If no folder exists creates a folder based on step4 user input   ** 6b. If folder exists matching step4 user input script will use the found folder to save revisions   ** 7a. If 6a, creates a .pdf file with step4 user input (Example: steve.pdf)   ** 7b. If 6b, creates a .pdf file with step4 user input + 2 (Example: steve2.pdf) (incrementally increases by 1 per 5,7 loop)    ** 8. Outlines all text found in document, including dimension labels   ** 9a. If 6a, creates a .ai file with step4 user input (Example: steve.ai)   ** 9b. If 6b, creates a .ai file with step4 user input + 2 (Example: steve2.ai) (incrementally increases by 1 per 5,9 loop)    **   ** Note:   ** If you want to run this on a non SG computer you need to edit variables: folderpath, PDFpath, AIpath to a directory found on your PC/MAC    **   ** ======================================*/ var docRef = app.activeDocument;var selectRef = docRef.pathItems;/*   ** ======================================   ** FIND ALL DIE LINES   ** ======================================*/ for ( var i = 0; i < selectRef.length; i++) {      if (selectRef[i].strokeColor.cyan == 0 && selectRef[i].strokeColor.magenta == 100 && selectRef[i].strokeColor.yellow == 0 && selectRef[i].strokeColor.black == 0)        docRef.pathItems[i].selected = selectRef[i].stroked;          }; /*   ** ======================================   ** ADD ART BOARDS   ** ======================================*/  docRef.artboards.setActiveArtboardIndex = 2;for (var i= selection.length - 1; i >= 0; i--) app.activeDocument.artboards.add(selection[i].geometricBounds);/*   ** ======================================   ** ADD DIMENSIONS   ** ======================================*/ /** * Specify (Steve Kornahrens edited this to fit SG needs, original ADD DIMENSIONS found at link below) * ======= * Version: 1.2.2 * https://github.com/adamdehaven/Specify * * Adam DeHaven * http://adamdehaven.com * @adamdehaven * * Additional info: * http://adamdehaven.com/blog/2015/05/dimension-adobe-illustrator-designs-with-a-simple-script/ * ====================*/  if (app.documents.length > 0) {       // Document  var doc = activeDocument;  // Count selected items  var selectedItems = parseInt(doc.selection.length, 10) || 0;  /*----------  Defaults  ----------*/  // Units  var setUnits = true;  var defaultUnits = $.getenv("Specify_defaultUnits") ? convertToBoolean($.getenv("Specify_defaultUnits")) : setUnits;  // Font Size  var setFontSize = 0.25;  var defaultFontSize = $.getenv("Specify_defaultFontSize") ? convertToUnits($.getenv("Specify_defaultFontSize")).toFixed(3) : setFontSize;  // Colors  var setRed = 147;  var defaultColorRed = $.getenv("Specify_defaultColorRed") ? $.getenv("Specify_defaultColorRed") : setRed;  var setGreen = 149;  var defaultColorGreen = $.getenv("Specify_defaultColorGreen") ? $.getenv("Specify_defaultColorGreen") : setGreen;  var setBlue = 152;  var defaultColorBlue = $.getenv("Specify_defaultColorBlue") ? $.getenv("Specify_defaultColorBlue") : setBlue;  // Decimals  var setDecimals = 3;  var defaultDecimals = $.getenv("Specify_defaultDecimals") ? $.getenv("Specify_defaultDecimals") : setDecimals;     /*----------  Dimensions  ----------*/  // Right  // rightCheckbox.value = true;  var rightCheckbox = true  // Left  // leftCheckbox.value = true;   var leftCheckbox = true;   // Top  // topCheckbox.value = true;  var topCheckbox = true  // Bottom  // bottomCheckbox.value = true;   var bottomCheckbox = true;      // SPEC layer  try {    var specsLayer = doc.layers["SPECS"];  } catch (err) {    var specsLayer = doc.layers.add();    specsLayer.name = "SPECS";  }  // Measurement line and text color in RGB  var color = new RGBColor;  // Declare global decimals var  var decimals;  // Gap between measurement lines and object  var gap = 14;  // Size of perpendicular measurement lines.  var size = 6;  // Start the spec  function startSpec() {    // Add all selected objects to array    var objectsToSpec = new Array();    for (var index = doc.selection.length - 1; index >= 0; index--) {      objectsToSpec[index] = doc.selection[index];    }    // Fetch desired dimensions    var top = topCheckbox.value;    var left = leftCheckbox.value;    var right = rightCheckbox;    var bottom = bottomCheckbox;    // Take focus away from fontSizeInput to validate (numeric)    //fontSizeInput.active = false;    // Set bool for numeric vars    var validFontSize = /^[0-9]{1,3}(\.[0-9]{1,3})?$/.test(setFontSize);    var validRedColor = 147;    var validGreenColor = 149;    var validBlueColor = 152;    // If colors are valid, set variables    if (validRedColor && validGreenColor && validBlueColor) {      color.red = 147;      color.green = 149;      color.blue = 152;      // Set environmental variables      $.setenv("Specify_defaultColorRed", color.red);      $.setenv("Specify_defaultColorGreen", color.green);      $.setenv("Specify_defaultColorBlue", color.blue);    }    var validDecimalPlaces = 2;    if (validDecimalPlaces) {      // Number of decimal places in measurement      decimals = 2;      // Set environmental variable      $.setenv("Specify_defaultDecimals", decimals);    }    if (selectedItems < 1) {      beep();      alert("Please select at least 1 object and try again.");      // Close dialog      specifyDialogBox.close();    } else if (!top && !left && !right && !bottom) {      beep();      alert("Please select at least 1 dimension to draw.");    } else if (!validFontSize) {      // If fontSizeInput.text does not match regex      beep();      alert("Please enter a valid font size. \n0.002 - 999.999");      fontSizeInput.active = true;      fontSizeInput.text = setFontSize;    } else if (parseFloat(.25, 10) <= 0.001) {      beep();      alert("Font size must be greater than 0.001.");      fontSizeInput.active = true;    } else if (!validRedColor || !validGreenColor || !validBlueColor) {      // If RGB inputs are not numeric      beep();      alert("Please enter a valid RGB color.");      colorInputRed.active = true;      colorInputRed.text = defaultColorRed;      colorInputGreen.text = defaultColorGreen;      colorInputBlue.text = defaultColorBlue;    } else if (!validDecimalPlaces) {      // If decimalPlacesInput.text is not numeric      beep();      alert("Decimal places must range from 0 - 4.");      decimalPlacesInput.active = true;      decimalPlacesInput.text = setDecimals;    //} else if (selectedItems == 2 && between.value) {    //  if (top) specDouble(objectsToSpec[0], objectsToSpec[1], "Top");    //  if (left) specDouble(objectsToSpec[0], objectsToSpec[1], "Left");    //  if (right) specDouble(objectsToSpec[0], objectsToSpec[1], "Right");    //  if (bottom) specDouble(objectsToSpec[0], objectsToSpec[1], "Bottom");      // Close dialog when finished      specifyDialogBox.close();    } else {      // Iterate over each selected object, creating individual dimensions as you go      for (var objIndex = objectsToSpec.length - 1; objIndex >= 0; objIndex--) {        if (top) specSingle(objectsToSpec[objIndex].geometricBounds, "Top");        if (left) specSingle(objectsToSpec[objIndex].geometricBounds, "Left");        if (right) specSingle(objectsToSpec[objIndex].geometricBounds, "Right");        if (bottom) specSingle(objectsToSpec[objIndex].geometricBounds, "Bottom");      }      // Close dialog when finished      //specifyDialogBox.close();    }  }  // Spec a single object  function specSingle(bound, where) {    // unlock SPECS layer    specsLayer.locked = false;    // width and height    var w = bound[2] - bound[0];    var h = bound[1] - bound[3];    // a & b are the horizontal or vertical positions that change    // c is the horizontal or vertical position that doesn't change    var a = bound[0];    var b = bound[2];    var c = bound[1];    // xy='x' (horizontal measurement), xy='y' (vertical measurement)    var xy = "x";    // a direction flag for placing the measurement lines.    var dir = 1;    switch (where) {      case "Top":        a = bound[0];        b = bound[2];        c = bound[1];        xy = "x";        dir = 1;        break;      case "Right":        a = bound[1];        b = bound[3];        c = bound[2];        xy = "y";        dir = 1;        break;      case "Bottom":        a = bound[0];        b = bound[2];        c = bound[3];        xy = "x";        dir = -1;        break;      case "Left":        a = bound[1];        b = bound[3];        c = bound[0];        xy = "y";        dir = -1;        break;    }    // Create the measurement lines    var lines = new Array();    // horizontal measurement    if (xy == "x") {      // 2 vertical lines      lines[0] = new Array(new Array(a, c + (gap) * dir));      lines[0].push(new Array(a, c + (gap + size) * dir));      lines[1] = new Array(new Array(b, c + (gap) * dir));      lines[1].push(new Array(b, c + (gap + size) * dir));      // 1 horizontal line      lines[2] = new Array(new Array(a, c + (gap + size / 2) * dir));      lines[2].push(new Array(b, c + (gap + size / 2) * dir));      // Create text label      if (where == "Top") {        var t = specLabel(w, (a + b) / 2, lines[0][1][1], color);        t.top += t.height;      } else {        var t = specLabel(w, (a + b) / 2, lines[0][0][1], color);        t.top -= size;      }      t.left -= t.width / 2;    } else {      // Vertical measurement      // 2 horizontal lines      lines[0] = new Array(new Array(c + (gap) * dir, a));      lines[0].push(new Array(c + (gap + size) * dir, a));      lines[1] = new Array(new Array(c + (gap) * dir, b));      lines[1].push(new Array(c + (gap + size) * dir, b));      //1 vertical line      lines[2] = new Array(new Array(c + (gap + size / 2) * dir, a));      lines[2].push(new Array(c + (gap + size / 2) * dir, b));      // Create text label      if (where == "Left") {        var t = specLabel(h, lines[0][1][0], (a + b) / 2, color);        t.left -= t.width;        t.rotate(90, true, false, false, false, Transformation.BOTTOMRIGHT);        t.top += t.width;        t.top += t.height / 2;      } else {        var t = specLabel(h, lines[0][1][0], (a + b) / 2, color);        t.rotate(-90, true, false, false, false, Transformation.BOTTOMLEFT);        t.top += t.width;        t.top += t.height / 2;      }    }    // Draw lines    var specgroup = new Array(t);    for (var i = 0; i < lines.length; i++) {      var p = doc.pathItems.add();      p.setEntirePath(lines[i]);      p.strokeDashes = []; // Prevent dashed SPEC lines      setLineStyle(p, color);      specgroup.push(p);    }    group(specsLayer, specgroup);    // re-lock SPECS layer    specsLayer.locked = false;  }  // Spec the gap between 2 elements  function specDouble(item1, item2, where) {    var bound = new Array(0, 0, 0, 0);    var a = item1.geometricBounds;    var b = item2.geometricBounds;    if (where == "Top" || where == "Bottom") {      if (b[0] > a[0]) { // item 2 on right,        if (b[0] > a[2]) { // no overlap          bound[0] = a[2];          bound[2] = b[0];        } else { // overlap          bound[0] = b[0];          bound[2] = a[2];        }      } else if (a[0] >= b[0]) { // item 1 on right        if (a[0] > b[2]) { // no overlap          bound[0] = b[2];          bound[2] = a[0];        } else { // overlap          bound[0] = a[0];          bound[2] = b[2];        }      }      bound[1] = Math.max(a[1], b[1]);      bound[3] = Math.min(a[3], b[3]);    } else {      if (b[3] > a[3]) { // item 2 on top        if (b[3] > a[1]) { // no overlap          bound[3] = a[1];          bound[1] = b[3];        } else { // overlap          bound[3] = b[3];          bound[1] = a[1];        }      } else if (a[3] >= b[3]) { // item 1 on top        if (a[3] > b[1]) { // no overlap          bound[3] = b[1];          bound[1] = a[3];        } else { // overlap          bound[3] = a[3];          bound[1] = b[1];        }      }      bound[0] = Math.min(a[0], b[0]);      bound[2] = Math.max(a[2], b[2]);    }    specSingle(bound, where);  }  // Create a text label that specify the dimension  function specLabel(val, x, y, color) {    var t = doc.textFrames.add();    // Get font size from specifyDialogBox.fontSizeInput    var labelFontSize;    if (parseFloat(.25 > 0)) {      labelFontSize = parseFloat(fontSizeInput.text);    } else {      labelFontSize = defaultFontSize;    }    // Convert font size to RulerUnits    var labelFontInUnits = convertToPoints(labelFontSize);    // Set environmental variable    $.setenv("Specify_defaultFontSize", labelFontInUnits);    t.textRange.characterAttributes.size = labelFontInUnits;    t.textRange.characterAttributes.alignment = StyleRunAlignmentType.center;    t.textRange.characterAttributes.fillColor = color;    // Conversions : http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/illustrator/sdk/CC2014/Illustrator%20Scripting%20Guide.pdf    // UnitValue object (page 230): http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/scripting/pdfs/javascript_tools_guide.pdf    var displayUnitsLabel = RulerUnits.Inches;    // Set environmental variable    $.setenv("Specify_defaultUnits", displayUnitsLabel);    var v = val;    var unitsLabel = "";    switch (doc.rulerUnits) {        case RulerUnits.Picas:          v = new UnitValue(v, "pt").as("pc");          var vd = v - Math.floor(v);          vd = 12 * vd;          v = Math.floor(v) + "p" + vd.toFixed(decimals);          break;        case RulerUnits.Inches:          v = new UnitValue(v, "pt").as("in");          v = v.toFixed(decimals);          unitsLabel = "\""; // add abbreviation          break;        case RulerUnits.Millimeters:          v = new UnitValue(v, "pt").as("mm");          v = v.toFixed(decimals);          unitsLabel = " mm"; // add abbreviation          break;        case RulerUnits.Centimeters:          v = new UnitValue(v, "pt").as("cm");          v = v.toFixed(decimals);          unitsLabel = " cm"; // add abbreviation          break;        case RulerUnits.Pixels:          v = new UnitValue(v, "pt").as("px");          v = v.toFixed(decimals);          unitsLabel = " px"; // add abbreviation          break;        default:          v = new UnitValue(v, "pt").as("pt");          v = v.toFixed(decimals);          unitsLabel = " pt"; // add abbreviation    }    if (displayUnitsLabel) {      t.contents = v + unitsLabel;    } else {      t.contents = v;    }    t.top = y;    t.left = x;    return t;  }  function convertToBoolean(string) {    switch(string.toLowerCase()) {        case "true":            return true;            break;        case "false":            return false;            break;    }  }  function setLineStyle(path, color) {    path.filled = false;    path.stroked = true;    path.strokeColor = color;    path.strokeWidth = 0.5;    return path;  }  // Group items in a layer  function group(layer, items, isDuplicate) {    // Create new group    var gg = layer.groupItems.add();    // Add to group    // Reverse count, because items length is reduced as items are moved to new group    for (var i = items.length - 1; i >= 0; i--) {      if (items[i] != gg) { // don't group the group itself        if (isDuplicate) {          newItem = items[i].duplicate(gg, ElementPlacement.PLACEATBEGINNING);        } else {          items[i].move(gg, ElementPlacement.PLACEATBEGINNING);        }      }    }    return gg;  }  function convertToPoints(value) {      switch (doc.rulerUnits) {          case RulerUnits.Picas:              value = new UnitValue(value, "pc").as("pt");              break;          case RulerUnits.Inches:              value = new UnitValue(value, "in").as("pt");              break;          case RulerUnits.Millimeters:              value = new UnitValue(value, "mm").as("pt");              break;          case RulerUnits.Centimeters:              value = new UnitValue(value, "cm").as("pt");              break;          case RulerUnits.Pixels:              value = new UnitValue(value, "px").as("pt");              break;          default:              value = new UnitValue(value, "pt").as("pt");      }      return value;  }  function convertToUnits(value) {      switch (doc.rulerUnits) {          case RulerUnits.Picas:              value = new UnitValue(value, "pt").as("pc");              break;          case RulerUnits.Inches:              value = new UnitValue(value, "pt").as("in");              break;          case RulerUnits.Millimeters:              value = new UnitValue(value, "pt").as("mm");              break;          case RulerUnits.Centimeters:              value = new UnitValue(value, "pt").as("cm");              break;          case RulerUnits.Pixels:              value = new UnitValue(value, "pt").as("px");              break;          default:              value = new UnitValue(value, "pt").as("pt");      }      return value;  }/* ** ====================================== ** RUN ADD DIMENSIONS SCRIPT ** ======================================*/  switch (selectedItems) {    case 0:      beep();      alert("Please select at least 1 object and try again.");      break;    default:            break;  }} else { // No active document  alert("There are no objects to Specify. \nPlease open a document to continue.")}startSpec();/* ** ====================================== ** CREATE FOLDER AND FILES ** ======================================*/// Variable Reset for Folder and File Creation //   var doc = app.activeDocument;var userValue = prompt("what is the File Name");var folderpath = new Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue);var PDFpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue + ".pdf");var AIpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue + ".ai");var pdfNum = 1;var aiNum = 1;// CREATE FOLDER //function createFolder() {     if (folderpath.exists){  do {  //alert("Folder " + userValue + " exists"); //TESTING FUNCTION  }  while (folderpath.exists);  }  else {    //alert("Folder not found"); //TESTING FUNCTION    folderpath = new Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue);  }  folderpath.create();};// CREATE PDF //function createPDF() {if (PDFpath.exists){  do {  //alert("PDF " + userValue + pdfNum + " exists"); //TESTING FUNCTION  pdfNum = pdfNum + 1;  PDFpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue + pdfNum + ".pdf");    }  while (PDFpath.exists);  }  else {    //alert("PDF not found"); //TESTING FUNCTION    PDFpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue);  };  var opts = new PDFSaveOptions();    opts.compatability = PDFCompatibility.ACROBAT6;  //opts.artboardRange = 1;  doc.saveAs(File(PDFpath), opts); };/* ** ====================================== ** OUTLINE FONTS ** ======================================*/function outlineDocText(  ) {              if ( app.documents.length == 0 ) return;        var docRef = app.activeDocument;                recurseLayers( docRef.layers );      };     function recurseLayers( objArray ) {                for ( var i = 0; i < objArray.length; i++ ) {                          // Record previous value with conditional change                      var l = objArray[i].locked;                      if ( l ) objArray[i].locked = false;                          // Record previous value with conditional change                      var v = objArray[i].visible;                      if ( !v ) objArray[i].visible = true;                          outlineText( objArray[i].textFrames );                          // Recurse the contained layer collection                      if ( objArray[i].layers.length > 0 ) {                                recurseLayers( objArray[i].layers )                      }                          // Recurse the contained group collection                      if ( objArray[i].groupItems.length > 0 ) {                                recurseGroups( objArray[i].groupItems )                      }                           // Return to previous values                      objArray[i].locked = l;                      objArray[i].visible = v;            }  };    function recurseGroups( objArray ) {                for ( var i = 0; i < objArray.length; i++ ) {                          // Record previous value with conditional change                      var l = objArray[i].locked;                      if ( l ) objArray[i].locked = false;                          // Record previous value with conditional change                      var h = objArray[i].hidden;                      if ( h ) objArray[i].hidden = false;                          outlineText( objArray[i].textFrames );                          // Recurse the contained group collection                      if ( objArray[i].groupItems.length > 0 ) {                                recurseGroups( objArray[i].groupItems )                      }                           // Return to previous values                      objArray[i].locked = l;                      objArray[i].hidden = h;            }  };      function outlineText( objArray ) {                // Reverse this loop as it brakes the indexing            for ( var i = objArray.length-1; i >= 0; i-- ) {                          // Record previous value with conditional change                      var l = objArray[i].locked;                      if ( l ) objArray[i].locked = false;                          // Record previous value with conditional change  R                    var h = objArray[i].hidden;                      if ( h ) objArray[i].hidden = false;                          var g = objArray[i].createOutline(  );                          // Return new group to previous Text Frame values                      g.locked = l;                      g.hidden = h;                }    };  /* ** ====================================== ** CREATE AI ** ======================================*/function createAI(){if (AIpath.exists){  do {  //alert("AI" + userValue + aiNum + " exists"); //TESTING FUNCTION  aiNum = aiNum + 1;  AIpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue + aiNum + ".ai");    }  while (AIpath.exists);  }  else {    //alert("AI not found"); //TESTING FUNCTION    AIpath = Folder("/Volumes/ShrData/server_docs/custom_stickers/Art For Robb" + "/" + userValue + "/" + userValue);  };  var opts = new IllustratorSaveOptions();    opts.compatibility = Compatibility.ILLUSTRATOR15;  doc.saveAs(File(AIpath), opts); };/* ** ====================================== ** THIS CALLS THE FUNCTIONS ABOVE TO CREATE FOLDER, PDF, AND OUTLINED AI.  ** CHECKS FOR EXISTING FILES FIRST AND CREATES REVISION FILES IF FOLDER/FILE EXIST  ** ======================================*/if (folderpath.exists){  createPDF();  outlineDocText();  createAI();} else {  createFolder();  createPDF();  outlineDocText();  createAI();}